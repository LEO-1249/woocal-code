/* -*- C++ -*-   vim: set syntax=cpp:
 * (C) Frankt-Rene Schaefer
 * ABSOLUTELY NO WARRANTY               */
#ifndef QUEX_INCLUDE_GUARD_a2l_quex_lexer__ANALYZER__MEMBER__MISC_I
#define QUEX_INCLUDE_GUARD_a2l_quex_lexer__ANALYZER__MEMBER__MISC_I

#include "a2l_quex_lexer\lib\analyzer/Counter"
#include "a2l_quex_lexer\lib\buffer/Buffer_print"
#include "a2l_quex_lexer\lib\buffer/lexatoms/LexatomLoader"
#include "a2l_quex_lexer\lib\lexeme/basics"





inline void 
a2l_quex_lexer_MF_error_code_clear(a2l_quex_lexer* me)
{ me->error_code = E_Error_None; }

inline void 
a2l_quex_lexer_MF_error_code_set_void(a2l_quex_lexer* me)
{ me->error_code = E_Error_Uninitialized; }

inline bool 
a2l_quex_lexer_MF_error_code_is_void(a2l_quex_lexer* me)
{ return me->error_code == E_Error_Uninitialized; }

inline void 
a2l_quex_lexer_MF_error_code_set_if_first(a2l_quex_lexer* me, E_Error ErrorCode)
/* Never overwrite an error code
 * => original error is maintained.                                           */
{ if( me->error_code == E_Error_None ) me->error_code = ErrorCode; }

inline a2l_quex_lexer_Token*  
a2l_quex_lexer_MF_token_p(a2l_quex_lexer* me)
{
    return me->_token_queue.write_iterator; 
}

inline void 
a2l_quex_lexer_MF_send(a2l_quex_lexer* me, 
                   a2l_quex_lexer_token_id_t  Id)
{ a2l_quex_lexer_TokenQueue_push(&me->_token_queue, Id); }

inline void 
a2l_quex_lexer_MF_send_n(a2l_quex_lexer* me, 
                     a2l_quex_lexer_token_id_t  Id, 
                     size_t              RepetitionN)
{ a2l_quex_lexer_TokenQueue_push_repeated(&me->_token_queue, Id, RepetitionN); }

inline bool 
a2l_quex_lexer_MF_send_text(a2l_quex_lexer* me, 
                        a2l_quex_lexer_token_id_t  Id,
                        a2l_quex_lexer_lexatom_t*  BeginP, 
                        a2l_quex_lexer_lexatom_t*  EndP)
{ return a2l_quex_lexer_TokenQueue_push_text(&me->_token_queue, Id, BeginP, EndP); }

inline bool 
a2l_quex_lexer_MF_send_string(a2l_quex_lexer* me,
                          a2l_quex_lexer_token_id_t  Id,
                          a2l_quex_lexer_lexatom_t*  ZeroTerminatedString)
{ 
    const size_t Length = a2l_quex_lexer_lexeme_length((const a2l_quex_lexer_lexatom_t*)ZeroTerminatedString);

    return a2l_quex_lexer_TokenQueue_push_text(&me->_token_queue, Id, ZeroTerminatedString, 
                                           ZeroTerminatedString + (ptrdiff_t)Length + 1); 
}

inline bool
a2l_quex_lexer_MF_byte_order_reversion(a2l_quex_lexer* me)
{ 
    __quex_assert(0 != me->buffer.filler);
    return me->buffer.filler->_byte_order_reversion_active_f; 
}

inline void     
a2l_quex_lexer_MF_byte_order_reversion_set(a2l_quex_lexer* me, bool Value)
{ 
    __quex_assert(0 != me->buffer.filler);
    me->buffer.filler->_byte_order_reversion_active_f = Value; 
}

inline const char*
a2l_quex_lexer_MF_input_name(a2l_quex_lexer* me)
{ return me->__input_name; }

inline bool
a2l_quex_lexer_MF_input_name_set(a2l_quex_lexer* me, const char* InputNameP)
/* Sets the 'input name', i.e. some string that identifies the input stream.
 * In case of failure '.__input_name' is set to NULL.
 *
 * RETURNS: true, for success. false, else.                                   */
{ 
    if( me->__input_name ) {
        quex::MemoryManager_free(me->__input_name, E_MemoryObjectType_INPUT_NAME);
    }
    if(  ! InputNameP ) {
        me->__input_name = (char*)0;
        return true;
    }
    else {
        me->__input_name = quex::MemoryManager_clone_string(InputNameP);
        return me->__input_name ? true : false;
    }
}

inline const char* 
a2l_quex_lexer_MF_version(a2l_quex_lexer* me)
{ 
    (void)me;
    return          QUEX_STRING(a2l_quex_lexer)           \
           ": Version "         QUEX_a2l_quex_lexer_SETTING_ANALYZER_VERSION \
           ". Date "            QUEX_a2l_quex_lexer_SETTING_BUILD_DATE       \
           "Generated by Quex " QUEX_a2l_quex_lexer_SETTING_VERSION ".";
}

inline void
a2l_quex_lexer_MF_print_this(a2l_quex_lexer* me)
{
    const char*       handler_name = (const char*)0;

    QUEX_DEBUG_PRINT1("  mode:       %s;\n", 
                      me->__current_mode_p == 0x0 ? "0x0" : me->__current_mode_p->name);
    QUEX_DEBUG_PRINT1("  error_code: %s;\n", E_Error_NAME(me->error_code));

    if( me->error_code != E_Error_None ) {
        handler_name = E_Error_MISSING_HANDLER_NAME(me->error_code);
        if( handler_name ) {
            QUEX_DEBUG_PRINT1("              (* '%s' has not been specified for mode*)\n", 
                              handler_name);
        }
    }

     a2l_quex_lexer_Counter_print_this(&me->counter);
    

    QUEX_DEBUG_PRINT("  _mode_stack: ");
    a2l_quex_lexer_ModeStack_print(&me->_mode_stack);

    a2l_quex_lexer_Buffer_print_this(&me->buffer);

    a2l_quex_lexer_user_print(me);

    if( me->error_code != E_Error_None ) {
        a2l_quex_lexer_Buffer_print_content_detailed(&me->buffer);
        QUEX_DEBUG_PRINT("\n\n");
    }
}


inline size_t a2l_quex_lexer_MF_line_number(const a2l_quex_lexer* me)            { return a2l_quex_lexer_MF_line_number_at_begin(me); }
inline size_t a2l_quex_lexer_MF_line_number_at_begin(const a2l_quex_lexer* me)   { return me->counter._line_number_at_begin; }
inline size_t a2l_quex_lexer_MF_line_number_at_end(const a2l_quex_lexer* me)     { return me->counter._line_number_at_end; }
inline void   a2l_quex_lexer_MF_line_number_set(a2l_quex_lexer* me, size_t Value) { me->counter._line_number_at_end = Value; }


inline size_t a2l_quex_lexer_MF_column_number(const a2l_quex_lexer* me)          { return a2l_quex_lexer_MF_column_number_at_begin(me); }
inline size_t a2l_quex_lexer_MF_column_number_at_begin(const a2l_quex_lexer* me) { return me->counter._column_number_at_begin; }
inline size_t a2l_quex_lexer_MF_column_number_at_end(const a2l_quex_lexer* me)   { return me->counter._column_number_at_end; }
inline void   a2l_quex_lexer_MF_column_number_set(a2l_quex_lexer* me, size_t Value) { me->counter._column_number_at_end = Value; }







#endif /* QUEX_INCLUDE_GUARD_a2l_quex_lexer__ANALYZER__MEMBER__MISC_I */
