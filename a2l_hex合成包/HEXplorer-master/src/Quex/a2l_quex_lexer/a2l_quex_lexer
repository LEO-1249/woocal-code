/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include "a2l_quex_lexer\lib\definitions"
 * (4) Lexical FSM class a2l_quex_lexer and its memento class.
 * (5) Constructor and init core of a2l_quex_lexer.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex 0.69.3.
 *
 * (C) 2005-2012 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef QUEX_INCLUDE_GUARD_a2l_quex_lexer__ANALYZER__GENERATED
#define QUEX_INCLUDE_GUARD_a2l_quex_lexer__ANALYZER__GENERATED

#include <cstddef>
#include "a2l_quex_lexer\lib\quex/compatibility/stdint.h"
#include "a2l_quex_lexer\a2l_quex_lexer-configuration"

#include "a2l_quex_lexer\lib\definitions"

/* Forward declarations ______________________________________________________*/
 
class a2l_quex_lexer_Memento;
class a2l_quex_lexer;    

typedef void  (*a2l_quex_lexer_AnalyzerFunctionP)(a2l_quex_lexer*);



class a2l_quex_lexer_Token;


/* User defined header content ________________________________________________
 * Must come before token class definition, since the token class 
 * might rely on contents of the header.                                     */

#   line 7 "a2l_quex_lexer.qx"

#include <cstdlib>  // for: atoi()

#   line 44 "a2l_quex_lexer\a2l_quex_lexer"



/* Declaration of all basic classes ___________________________________________
 *                                                                           */
#include "a2l_quex_lexer\lib\declarations"

/* Token class and token id definitions _______________________________________
 *                                                                           */
#include "a2l_quex_lexer\a2l_quex_lexer-token_ids"
 
extern const char* a2l_quex_lexer_map_token_id_to_name(const a2l_quex_lexer_token_id_t TokenID);
 
#include "a2l_quex_lexer\a2l_quex_lexer-token"

 

extern a2l_quex_lexer_Mode  a2l_quex_lexer_ONE_AND_ONLY;


extern  void a2l_quex_lexer_ONE_AND_ONLY_analyzer_function(a2l_quex_lexer* me);
#ifdef QUEX_OPTION_ASSERTS
extern  bool a2l_quex_lexer_ONE_AND_ONLY_has_base(const a2l_quex_lexer_Mode* mode);
#endif
#ifdef QUEX_OPTION_ASSERTS
extern  bool a2l_quex_lexer_ONE_AND_ONLY_has_entry_from(const a2l_quex_lexer_Mode* mode);
#endif
#ifdef QUEX_OPTION_ASSERTS
extern  bool a2l_quex_lexer_ONE_AND_ONLY_has_exit_to(const a2l_quex_lexer_Mode* mode);
#endif
extern  void a2l_quex_lexer_ONE_AND_ONLY_on_buffer_before_change(void* aux);
extern  void a2l_quex_lexer_ONE_AND_ONLY_on_buffer_overflow(void* aux);
extern  void a2l_quex_lexer_ONE_AND_ONLY_on_entry(a2l_quex_lexer* me, const a2l_quex_lexer_Mode* mode);
extern  void a2l_quex_lexer_ONE_AND_ONLY_on_exit(a2l_quex_lexer* me, const a2l_quex_lexer_Mode* mode);



typedef bool (*a2l_quex_lexer_callback_on_token_type)(a2l_quex_lexer_Token*);

class QUEX_a2l_quex_lexer_SETTING_USER_CLASS_DECLARATION_EPILOG_EXT a2l_quex_lexer_Memento {
public:
    a2l_quex_lexer_Memento()  {} /* Con- and Destruction necessary to trigger */
    ~a2l_quex_lexer_Memento() {} /* con- and destruction of user members.     */

    char*                             __input_name;
    a2l_quex_lexer_Buffer                 buffer;

    const struct a2l_quex_lexer_Mode_tag* __current_mode_p; 
    a2l_quex_lexer_AnalyzerFunctionP      current_analyzer_function;
           a2l_quex_lexer_Counter  counter;
    
    a2l_quex_lexer_Memento*               _parent_memento;

/* START: User's memento extentions __________________________________________*/

/* END: ______________________________________________________________________*/

#   if defined(QUEX_OPTION_ASSERTS)
    a2l_quex_lexer_AnalyzerFunctionP    DEBUG_analyzer_function_at_entry;
#   endif
};

class QUEX_a2l_quex_lexer_SETTING_USER_CLASS_DECLARATION_EPILOG_EXT a2l_quex_lexer {
public:
    /* __( Data Members )_______________________________________________________
     *                                                                        */
    a2l_quex_lexer_Buffer               buffer;
    a2l_quex_lexer_TokenQueue           _token_queue;  
    a2l_quex_lexer_ModeStack            _mode_stack;

    E_Error                         error_code;
    char*                           __input_name;

    const a2l_quex_lexer_Mode*          __current_mode_p; 
    /* Shortcut to current mode's analyzer function.                          */
    a2l_quex_lexer_AnalyzerFunctionP    current_analyzer_function;
#   if defined(QUEX_OPTION_ASSERTS)
    /* Backup of analyzer's function pointer => mode change detection.        */
    a2l_quex_lexer_AnalyzerFunctionP    DEBUG_analyzer_function_at_entry;
#   endif
           a2l_quex_lexer_Counter  counter;
    
    a2l_quex_lexer_Memento*                 _parent_memento;

public:
    typedef a2l_quex_lexer_Token      token_type;
    typedef a2l_quex_lexer_token_id_t   token_id_type;
    typedef a2l_quex_lexer_lexatom_t    char_type;

    /*__( Constructors )________________________________________________________
     *                                                                        */
    a2l_quex_lexer()
         { a2l_quex_lexer_MF_resources_absent_mark(this); error_code = E_Error_Uninitialized; }

    a2l_quex_lexer(const char*      Filename, 
                    a2l_quex_lexer_Converter* Converter = 0) 
         { a2l_quex_lexer_from_file_name(this, Filename, Converter); }

    a2l_quex_lexer(a2l_quex_lexer_ByteLoader*  byte_loader, 
                    a2l_quex_lexer_Converter*        Converter = 0) 
         { a2l_quex_lexer_from_ByteLoader(this, byte_loader, Converter); }

    a2l_quex_lexer(a2l_quex_lexer_lexatom_t* BufferMemoryBegin, 
                    size_t                  BufferMemorySize,
                    a2l_quex_lexer_lexatom_t*      BufferEndOfContentP = 0x0)
         { a2l_quex_lexer_from_memory(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    /* Named placement-new functions.                                         */
    static a2l_quex_lexer* from_file_name(const char*           Filename, 
                                                a2l_quex_lexer_Converter* Converter = 0) 
         { return new a2l_quex_lexer(Filename, Converter); }

    static a2l_quex_lexer* from_ByteLoader(a2l_quex_lexer_ByteLoader*  byte_loader, 
                                                 a2l_quex_lexer_Converter*   Converter = 0) 
         { return new a2l_quex_lexer(byte_loader, Converter); }

    static a2l_quex_lexer* from_memory(a2l_quex_lexer_lexatom_t* BufferMemoryBegin, 
                                             size_t             BufferMemorySize,
                                             a2l_quex_lexer_lexatom_t* BufferEndOfContentP = 0x0)
         { return new a2l_quex_lexer(BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    virtual ~a2l_quex_lexer()
         { a2l_quex_lexer_destruct(this); }
public:
    /*__( Reset )_______________________________________________________________
     *                                                                        */
    bool reset() { return a2l_quex_lexer_MF_reset(this); }
    bool reset_file_name(const char* FileName, a2l_quex_lexer_Converter* Converter = 0) { return a2l_quex_lexer_MF_reset_file_name(this, FileName, Converter); }
    bool reset_ByteLoader(a2l_quex_lexer_ByteLoader* byte_loader, a2l_quex_lexer_Converter* Converter = 0) { return a2l_quex_lexer_MF_reset_ByteLoader(this, byte_loader, Converter); }
    bool reset_memory(a2l_quex_lexer_lexatom_t* BufferMemoryBegin, size_t BufferMemorySize, a2l_quex_lexer_lexatom_t* BufferEndOfContentP) { return a2l_quex_lexer_MF_reset_memory(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    /*__( Include From and To Substream )_______________________________________
     *                                                                        */
    bool include_push_file_name(const char* FileName, a2l_quex_lexer_Converter* Converter = 0) { return a2l_quex_lexer_MF_include_push_file_name(this, FileName, Converter); }
    bool include_push_ByteLoader(const char* InputName, a2l_quex_lexer_ByteLoader* byte_loader, a2l_quex_lexer_Converter* Converter) { return a2l_quex_lexer_MF_include_push_ByteLoader(this, InputName, byte_loader, Converter); }
    bool include_push_memory(const char* InputName, a2l_quex_lexer_lexatom_t* BufferMemoryBegin, size_t BufferMemorySize, a2l_quex_lexer_lexatom_t* BufferEndOfContentP) { return a2l_quex_lexer_MF_include_push_memory(this, InputName, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }
    bool include_pop() { return a2l_quex_lexer_MF_include_pop(this); }
    void include_stack_delete() { a2l_quex_lexer_MF_include_stack_delete(this); }
    bool include_detect_recursion(const char* InputName) { return a2l_quex_lexer_MF_include_detect_recursion(this, InputName); }

    /*__( Receiving Tokens -- from outside lexer )_____________________________
     *                                                                       */
    bool run(a2l_quex_lexer_callback_on_token_type on_token, bool ErrorPrintF) { return a2l_quex_lexer_MF_run(this, on_token, ErrorPrintF); }
    void receive(a2l_quex_lexer_Token** token_pp) { a2l_quex_lexer_MF_receive(this, token_pp); }

    /*__( Sending Tokens -- from inside lexer )________________________________
     *                                                                       */
    a2l_quex_lexer_Token* token_p() { return a2l_quex_lexer_MF_token_p(this); }

    void send(a2l_quex_lexer_token_id_t Id) { a2l_quex_lexer_MF_send(this, Id); }
    void send_n(a2l_quex_lexer_token_id_t Id, size_t RepetitionN) { a2l_quex_lexer_MF_send_n(this, Id, RepetitionN); }
    bool send_text(a2l_quex_lexer_token_id_t Id, a2l_quex_lexer_lexatom_t* BeginP, a2l_quex_lexer_lexatom_t* EndP) { return a2l_quex_lexer_MF_send_text(this, Id, BeginP, EndP); }
    bool send_string(a2l_quex_lexer_token_id_t Id, a2l_quex_lexer_lexatom_t* ZeroTerminatedString) { return a2l_quex_lexer_MF_send_string(this, Id, ZeroTerminatedString); }

    /*__( Mode Handling )______________________________________________________
     *                                                                       */
    const a2l_quex_lexer_Mode* mode() { return a2l_quex_lexer_MF_mode(this); }
    void set_mode_brutally(const a2l_quex_lexer_Mode* Mode) { a2l_quex_lexer_MF_set_mode_brutally(this, Mode); }
    void enter_mode(const a2l_quex_lexer_Mode* TargetMode) { a2l_quex_lexer_MF_enter_mode(this, TargetMode); }

    void pop_mode() { a2l_quex_lexer_MF_pop_mode(this); }
    void pop_drop_mode() { a2l_quex_lexer_MF_pop_drop_mode(this); }
    void push_mode(a2l_quex_lexer_Mode* new_mode) { a2l_quex_lexer_MF_push_mode(this, new_mode); }

    /*__( Line/Column Counter )________________________________________________
     *                                                                       */
    size_t line_number() { return a2l_quex_lexer_MF_line_number(this); }
    size_t line_number_at_begin() { return a2l_quex_lexer_MF_line_number_at_begin(this); }
    size_t line_number_at_end() { return a2l_quex_lexer_MF_line_number_at_end(this); }
    void line_number_set(size_t Y) { a2l_quex_lexer_MF_line_number_set(this, Y); }

    size_t column_number() { return a2l_quex_lexer_MF_column_number(this); }
    size_t column_number_at_begin() { return a2l_quex_lexer_MF_column_number_at_begin(this); }
    size_t column_number_at_end() { return a2l_quex_lexer_MF_column_number_at_end(this); }
    void column_number_set(size_t X) { a2l_quex_lexer_MF_column_number_set(this, X); }

    /*__( Indentation )________________________________________________________
     *                                                                       */
    

public:
    /*__( General Information )________________________________________________
     *                                                                       */
    const char* version() { return a2l_quex_lexer_MF_version(this); }
    void print_this() { a2l_quex_lexer_MF_print_this(this); }
    const char* input_name() { return a2l_quex_lexer_MF_input_name(this); }
    bool input_name_set(const char* InputName) { return a2l_quex_lexer_MF_input_name_set(this, InputName); }

    /*__( Navigation: Tell/Seek )______________________________________________
     *                                                                       */
    size_t tell() { return a2l_quex_lexer_MF_tell(this); }
    void seek(const size_t CharacterIndex) { a2l_quex_lexer_MF_seek(this, CharacterIndex); }
    void seek_forward(const size_t CharacterN) { a2l_quex_lexer_MF_seek_forward(this, CharacterN); }
    void seek_backward(const size_t CharacterN) { a2l_quex_lexer_MF_seek_backward(this, CharacterN); }
                
    void undo() { a2l_quex_lexer_MF_undo(this); }
    void undo_n(size_t DeltaN_Backward) { a2l_quex_lexer_MF_undo_n(this, DeltaN_Backward); }

    /*__( Byte Order Reversion Activation / Deactivation )_____________________
     *                                                                       */
    bool byte_order_reversion() { return a2l_quex_lexer_MF_byte_order_reversion(this); }
    void byte_order_reversion_set(bool Value) { a2l_quex_lexer_MF_byte_order_reversion_set(this, Value); }

    /*__( Error Codes )________________________________________________________
     *                                                                       */
    void error_code_clear() { a2l_quex_lexer_MF_error_code_clear(this); }
    bool error_code_is_void() { return a2l_quex_lexer_MF_error_code_is_void(this); }
    void error_code_set_void() { a2l_quex_lexer_MF_error_code_set_void(this); }
    void error_code_set_if_first(E_Error ErrorCode) { a2l_quex_lexer_MF_error_code_set_if_first(this, ErrorCode); }

    /*__( Deep Resources )_____________________________________________________
     *                                                                       */
    void collect_user_memory(a2l_quex_lexer_lexatom_t** user_memory_p) { a2l_quex_lexer_MF_collect_user_memory(this, user_memory_p); }
    void resources_absent_mark() { a2l_quex_lexer_MF_resources_absent_mark(this); }
    bool resources_absent() { return a2l_quex_lexer_MF_resources_absent(this); }

#define self  (*(a2l_quex_lexer*)this)
/* START: User's class body extensions _______________________________________*/

/* END: ______________________________________________________________________*/
#undef  self

public:
    /* Befriend all modes                                                     */
    friend  void a2l_quex_lexer_ONE_AND_ONLY_analyzer_function(a2l_quex_lexer* me);
#ifdef QUEX_OPTION_ASSERTS
    friend  bool a2l_quex_lexer_ONE_AND_ONLY_has_base(const a2l_quex_lexer_Mode* mode);
#endif
#ifdef QUEX_OPTION_ASSERTS
    friend  bool a2l_quex_lexer_ONE_AND_ONLY_has_entry_from(const a2l_quex_lexer_Mode* mode);
#endif
#ifdef QUEX_OPTION_ASSERTS
    friend  bool a2l_quex_lexer_ONE_AND_ONLY_has_exit_to(const a2l_quex_lexer_Mode* mode);
#endif
    friend  void a2l_quex_lexer_ONE_AND_ONLY_on_buffer_before_change(void* aux);
    friend  void a2l_quex_lexer_ONE_AND_ONLY_on_buffer_overflow(void* aux);
    friend  void a2l_quex_lexer_ONE_AND_ONLY_on_entry(a2l_quex_lexer* me, const a2l_quex_lexer_Mode* mode);
    friend  void a2l_quex_lexer_ONE_AND_ONLY_on_exit(a2l_quex_lexer* me, const a2l_quex_lexer_Mode* mode);

  
private:
    a2l_quex_lexer(const a2l_quex_lexer&);                   /* Forbidden */
    a2l_quex_lexer& operator=(const a2l_quex_lexer& Other); /* Forbidden */

};





#include "a2l_quex_lexer\lib\implementations-inline.i"

/* START: User defined header content _________________________________________
 *        The 'footer' content relies on class definitions made above.        */



#endif /* QUEX_INCLUDE_GUARD_a2l_quex_lexer__ANALYZER__GENERATED */